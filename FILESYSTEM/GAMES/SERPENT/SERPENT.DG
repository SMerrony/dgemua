/*=====================================================================


	TITLE:		SERPENT

	DESCRIPTION:	SNAKE GAME PROGRAM

	AUTHOR:		WM. D. BRISCOE

	REVISION HISTORY:
	REV  DATE	COMMENTS
	--  ---------	-----------------------------------------------

	00  28 JAN 81	INITIAL IMPLEMENTATION

	01  17 MAR 81	ADDED FINAL SCORE DISPLAY FOLLOWING LOG
			DISPLAY; ALSO ERROR HANDLING ON LOG FILE
			ACCESS.

	1.1 14 JUL 81	REMOVE LEVEL QUESTION.
			REMOVE PLAY AGAIN DUE TO VS/DGL SYSTEM BUG.
			(John Quinn)

=====================================================================*/



BEGIN

EXTERNAL PROCEDURE

	LINEREAD,	SEED,		RANDOM,		CREATE,
	TASK,		TIDKILL,	PRIORITY,	GTIME,
	READERROR,	BREAKFILE,	SYSRETURN,	USERNAME,
	TRANSMIT,	RECEIVE;


EXTERNAL STRING PROCEDURE

	GETCINPUT,	GETCOUTPUT,	ERRMESSAGE;


EXTERNAL INTEGER

	STRSIZE,	BITSIZE;


GLOBAL INTEGER

	CTL_WORD,	CTL_LOCK;


INTEGER

	TOTAL_SCORE,	FINAL_LENGTH,	LOG_WRITE_ERR;


BOOLEAN
	PLAY_AGAIN;


STRING (BUFLGT) BUFFER;		% GENERAL-PURPOSE  BUFFER

LITERAL
	INPCHAN		(0),
	OUTCHAN		(1),
	LOGCHAN		(2),
	LOGNAME		("SERPENT_SCORERS"),
	DOCCHAN		(2),
	DOCNAME		("SERPENT.DOC"),
	READTASKID	(3),
	END_OF_FILE	(30R8),		% AOS ERROR CODE
	BUFLGT		(2048),
	SCRSIZE		(1920),		% CHARACTER COUNT ON SCREEN
	MAX_TARGETS	(19),		% MAXIMUM TARGET COUNT
	SNAKE_CHAR	("#"),		% FOR BUILDING SNAKE
	COLLISION_CHAR	(".");		% WHEN SNAKE COLLIDES AND DIES


%  DATA GENERAL CRT TERMINAL CONTROL CHARACTERS

LITERAL
	CRT_WAIT	("<000>"),	% NULL
	CRT_PRINT_FORM	("<001>"),	% PRINT ONLY HIGH-INTENSITY
	CRT_BLINKENA	("<003>"),	% ENABLE BLINK
	CRT_BLINKDISA	("<004>"),	% DISABLE BLINK
	CRT_READCURSOR	("<005>"),	% READ CURSOR ADDRESS
	CRT_BELL	("<007>"),	% AUDIBLE ALARM
	CRT_HOME	("<010>"),	% CURSOR HOME
	CRT_TAB		("<011>"),	% HORIZONTAL TAB
	CRT_NEWLINE	("<012>"),	% NEWLINE (FORMERLY LINE FEED)
	CRT_ERASE_EOL	("<013>"),	% ERASE TO END OF LINE
	CRT_ERASE_PAGE	("<014>"),	% ERASE PAGE
	CRT_RTRN	("<015>"),	% CARRIAGE RETURN
	CRT_START_BLINK	("<016>"),	% START BLINK
	CRT_END_BLINK	("<017>"),	% END BLINK
	CRT_MOVE	("<020>"),	% WRITE CURSOR ADDRESS
	CRT_PRINT	("<021>"),	% PRINT ALL FROM CURSOR POS.
	CRT_ROLL	("<022>"),	% ROLL MODE
	CRT_PAGE	("<023>"),	% PAGE MODE
	CRT_START_UNDER	("<024>"),	% START UNDERSCORE
	CRT_END_UNDER	("<025>"),	% END UNDERSCORE
	CRT_UP		("<027>"),	% CURSOR UP
	CRT_RIGHT	("<030>"),	% CURSOR RIGHT
	CRT_LEFT	("<031>"),	% CURSOR LEFT
	CRT_DOWN	("<032>"),	% CURSOR DOWN
	CRT_ESC		("<033>"),	% ESCAPE
	CRT_DIM		("<034>"),	% START LOW INTENSITY
	CRT_BRIGHT	("<035>"),	% END LOW INTENSITY
	CRT_FNKEY	("<036>"),	% FUNCTION KEY PREFIX
	CRT_READ_HDR	("<037>"),	% HEADER FOR READ CURSOR POS.
	CRT_DEL		("<177>"),	% DELETE
	CRT_START_RVID	("<036><104>"),	% START REVERSE VIDEO
	CRT_END_RVID	("<036><105>");	% END REVERSE VIDEO

PROCEDURE PUTBUFFER;

BEGIN
INTEGER CHAR_CNT;
CHAR_CNT := LENGTH (BUFFER);
IF CHAR_CNT > 0 THEN BEGIN
	BYTEWRITE (OUTCHAN, ADDRESS(BUFFER), CHAR_CNT);
	SETCURRENT (BUFFER, 0);
	END IF;
END PUTBUFFER;



PROCEDURE GETBYTE;

BEGIN
INTEGER CHAR_CNT, GARBAGE;
STRING (1) LOCALSTRING;
DO BEGIN
	CHAR_CNT := 1;
	BYTEREAD (INPCHAN, ADDRESS(LOCALSTRING), CHAR_CNT);
	CTL_WORD := BYTE (LOCALSTRING, 1) AND 177R8;	% IGNORE PARITY
	RECEIVE (GARBAGE, CTL_LOCK);
END LOOP;
END GETBYTE;



PROCEDURE INIT_PROGRAM;

BEGIN
OPEN (INPCHAN, (GETCINPUT));
OPEN (OUTCHAN, (GETCOUTPUT));
STRSIZE := BUFLGT;
BITSIZE := SCRSIZE;
PLAY_AGAIN := TRUE;
SEED;
PRIORITY (2);
END INIT_PROGRAM;



PROCEDURE TERMINATE_PROGRAM;

BEGIN
BUFFER := CRT_ROLL !! XY_STR (0, 22) !! CRT_NEWLINE;
PUTBUFFER;
CLOSE (INPCHAN);
CLOSE (OUTCHAN);
SYSRETURN;
END TERMINATE_PROGRAM;

PROCEDURE GET_START;

BEGIN

	INTEGER CHRCNT;
	STRING (133) LOCALSTRING;

	% IF DOCUMENTATION FILE IS AVAILABLE, DISPLAY IT

	BUFFER := CRT_ERASE_PAGE;
	PUTBUFFER;

	OPEN (DOCCHAN, DOCNAME, OPENERR);
	DO BEGIN		% READ EACH LINE AND PUT IT IN BUFFER
		LINEREAD (
			DOCCHAN,
          		ADDRESS (LOCALSTRING),
			CHRCNT,
			SIZE (LOCALSTRING),
			DOCERR);
		SETCURRENT (LOCALSTRING, CHRCNT);
		BUFFER := BUFFER !! LOCALSTRING;
	END LOOP;
	DOCERR:
	CLOSE (DOCCHAN);
	OPENERR:

	% WAIT UNTIL HE IS READY

	BUFFER := BUFFER !! "When ready, press any key.";
	PUTBUFFER;
	BYTEREAD (INPCHAN, ADDRESS (BUFFER), CHRCNT:=1);

END GET_START;



% BUILD A STRING TO POSITION THE CURSOR

STRING(3) PROCEDURE XY_STR (X,Y);

        INTEGER         X,Y;
BEGIN
        BASED STRING(2) STR2;
        LITERAL         X_STR (SUBSTR(ADDRESS(X)->STR2,2)),
                        Y_STR (SUBSTR(ADDRESS(Y)->STR2,2));

        XY_STR := "<20>"!!X_STR!!Y_STR;
END;

PROCEDURE GENERATE_OUTPUT;

BEGIN
INTEGER
	LOCAL_CONTROL,
	NEXT_LOCATION,
	END_LOCATION,
	NEXT_BITPOINTER,
	END_BITPOINTER,
	LENGTH_CONTROL,
	LENGTH_VALUE;

INTEGER
	DIRECTION;

LITERAL			% VALUES FOR DIRECTION
	GO_UP		(0),
	GO_DOWN		(1),
	GO_RIGHT	(2),
	GO_LEFT		(3);



% THE FOLLOWING ARRAY CONTAINS A VALUE WHICH CAN BE ADDED TO THE
% CURRENT HEAD LOCATION IN ORDER TO COMPUTE THE NEXT HEAD LOCATION.
% IT IS INDEXED BY [DIRECTION].

INTEGER ARRAY DISPLACEMENT [GO_UP:GO_LEFT];



BOOLEAN				% ---- IF TRUE:
	STILL_RUNNING,		% GAME STILL IN PROGRESS
	DOUBLE_SCORE,		% SNAKE LENGTH > 200
	HAS_SCORE,		% SCORE LEGEND HAS BEEN DISPLAYED
	HAS_TOTAL,		% TOTAL LEGEND HAS BEEN DISPLAYED
	HAS_LENGTH;		% LENGTH LEGEND HAS BEEN DISPLAYED

LITERAL LENGTH_INTERVAL (8);	% HOW OFTEN TO LENGTHEN SNAKE



% THE FOLLOWING IS USED IN KEEPING TRACK OF WHERE THE SNAKE HAS BEEN
% SO THAT THE TAIL GETS ERASED IN THE SAME ORDER IN WHICH THE HEAD
% CREATED IT.  EACH SNAKE SEGMENT IS REPRESENTED BY A TWO-BYTE SUB-
% STRING CONTAINING THE COLUMN AND ROW POSITION OF THE SEGMENT.

STRING (3432) SNAKEPOSITIONS;

% THE FOLLOWING ARE USED FOR DETECTING COLLISIONS AND FOR DETERMINING
% THE PLACEMENT OF TARGETS.  EACH BIT REPRESENTS A SCREEN LOCATION
% WHICH IS DETERMINED BY <BITPOINTER> := <ROW>*80+<COLUMN>+1 WHERE
% <BITPOINTER> STARTS AT ONE AND <ROW> AND <COLUMN> START AT ZERO.

BIT (SCRSIZE)
	SNAKEBITS,		% SPACES OCCUPIED BY SNAKE AND WALLS
	TARGETBITS,		% SPACES OCCUPIED BY TARGETS
	SNAKE_AND_TARGETS;	% SNAKEBITS .AND. TARGETBITS

BIT (165)			% TEMPLATE FOR FINDING POTENTIAL TARGET
	SAMPLE_TARGET,		% LOCATIONS AND FOR CREATING AND
	NOT_SAMPLE_TARGET;	% DELETING THEM



% THE FOLLOWING ARE USED TO KEEP TRACK OF CURRENT TARGET POSITIONS,
% THEIR POINT VALUES, AND WHEN TO DELETE THEM IF THE SNAKE DOESN'T
% HIT THEM FIRST.

INTEGER
	TARG_COUNT;		% CURRENT NUMBER OF TARGETS

INTEGER ARRAY
	TARG_BITPOINTER	[1:MAX_TARGETS],
	TARG_POINTS	[1:MAX_TARGETS],
	TARG_DURATION	[1:MAX_TARGETS];



% THE FOLLOWING RECORDS WHETHER THE VALUE OF A GIVEN TARGET IS
% CONCEALED FROM THE PLAYER.

BOOLEAN ARRAY
	TARG_SURPRIZE	[1:MAX_TARGETS];

% LOAD THE BUFFER WITH <BEEPCOUNT> NUMBER OF BEEPS, SEPARATED BY
% ENOUGH NULLS TO MAKE EACH BEEP SOUND DISTINCTLY AT 9600 BAUD.

PROCEDURE MULTIBEEP (BEEPCOUNT);

	INTEGER BEEPCOUNT;

BEGIN
BUFFER := BUFFER !! CRT_BELL;
IF BEEPCOUNT > 1 THEN BEGIN
	INTEGER I;
	FOR I := 1 STEP 1 UNTIL 40 DO BUFFER := BUFFER !! "<0>";
	BUFFER := BUFFER !! CRT_BELL;
	I := 2;		% NUMBER OF BEEPS SO FAR
	WHILE I < BEEPCOUNT DO BEGIN
		BUFFER := BUFFER !! SUBSTR
			(BUFFER, LENGTH(BUFFER)-40, LENGTH (BUFFER));
		I := I + 1;
		END LOOP;
	END IF;
END MULTIBEEP;



% BUILD THE SCREEN IMAGE OF THE WALLS IN THE BUFFER, USING THE MINIMUM
% NUMBER OF OVERHEAD CHARACTERS FOR CURSOR POSITIONING.

PROCEDURE MAKE_WALLS;

BEGIN
INTEGER I;
BUFFER := BUFFER !! CRT_PAGE !! CRT_ERASE_PAGE !! "+";
FOR I := 1 STEP 1 UNTIL 78 DO BUFFER := BUFFER !! "-";
BUFFER := BUFFER !! "+|";
FOR I := 1 STEP 1 UNTIL 21 DO
	BUFFER := BUFFER !! CRT_NEWLINE !! CRT_LEFT !! "||";
BUFFER := BUFFER !! CRT_NEWLINE !! CRT_LEFT !! "|" 
	!! SUBSTR (BUFFER, 3 ,82);
END MAKE_WALLS;

PROCEDURE INIT_GAME;

BEGIN
INTEGER I;

CTL_WORD := CTL_LOCK := 0;
TASK (GETBYTE, 0, READTASKID, 1, 300);

TOTAL_SCORE := TARG_COUNT := 0;
SETCURRENT (BUFFER, 0);
SETCURRENT (SNAKEBITS, SCRSIZE);
SETCURRENT (TARGETBITS, SCRSIZE);
SETCURRENT (SNAKE_AND_TARGETS, SCRSIZE);
SETCURRENT (SAMPLE_TARGET, 165);
SETCURRENT (NOT_SAMPLE_TARGET, 165);


% SET SNAKEBITS TO INDICATE POSITIONS OF WALLS

SUBSTR (SNAKEBITS, 1, 81) := -1;
SUBSTR (SNAKEBITS, 82, 159) := 0;
SUBSTR (SNAKEBITS, 160) := TRUE;
FOR I := 161 STEP 80 UNTIL 1761 DO
	SUBSTR (SNAKEBITS, I, I+79) := SUBSTR (SNAKEBITS, 81,160);
SUBSTR (SNAKEBITS, 1840, 1920) := SUBSTR (SNAKEBITS, 1, 80);
SUBSTR (TARGETBITS, 1, SCRSIZE) := 0;	% NO TARGETS YET


% SET UP TARGET TEMPLATES

SUBSTR (SAMPLE_TARGET, 1, 160) := 0;
SUBSTR (NOT_SAMPLE_TARGET, 1, 160) := -1;
FOR I := 1 STEP 80 UNTIL 161 DO BEGIN
	SUBSTR (SAMPLE_TARGET, I, I+4) := -1;
	SUBSTR (NOT_SAMPLE_TARGET, I, I+4) := 0;
	END LOOP;


% SET UP BUFFER TO CREATE WALLS ON SCREEN

MAKE_WALLS;


% SET UP INITIAL SNAKE AND ITS ATTRIBUTES

SUBSTR (SNAKEBITS, 82, 83) := -1;
SNAKE_AND_TARGETS := SNAKEBITS;
SNAKEPOSITIONS := "<1><1><2><1>";
BUFFER := BUFFER !! XY_STR (1, 1) !! "##";
DIRECTION := GO_RIGHT;
LENGTH_CONTROL := 0;

% PUT THE ENTIRE MESS ON THE SCREEN IN ONE SHOT

PUTBUFFER;

% SET UP MISCELLANEOUS VARIABLES

DISPLACEMENT [GO_UP] := -1;
DISPLACEMENT [GO_DOWN] := +1;
DISPLACEMENT [GO_RIGHT] := +400R8;
DISPLACEMENT [GO_LEFT] := -400R8;
STILL_RUNNING := TRUE;
DOUBLE_SCORE := HAS_TOTAL := HAS_SCORE := HAS_LENGTH := FALSE;

END INIT_GAME;

% CONVERT A BIT POINTER TO ITS CORRESPONDING SCREEN LOCATION

INTEGER PROCEDURE BIT_TO_LOC (BITPOINTER);
	INTEGER BITPOINTER;
BEGIN
BIT_TO_LOC := MOD (BITPOINTER-1, 80) * 400R8 + (BITPOINTER-1) / 80;
END BIT_TO_LOC;





% CONVERT A SCREEN LOCATION TO ITS CORRESPONDING BIT POINTER

INTEGER PROCEDURE LOC_TO_BIT (LOCATION);
	INTEGER LOCATION;
BEGIN
LOC_TO_BIT := BYTE (LOCATION, 2) * 80 + BYTE (LOCATION, 1) + 1;
END LOC_TO_BIT;






% RETURN A UNIFORMLY-DISTRIBUTED RANDOM REAL VALUE
% SUCH THAT 0 < VALUE < 1.

REAL PROCEDURE REAL_UNIFORM;

BEGIN
INTEGER I;
RANDOM (I);
REAL_UNIFORM := (FLOAT (I) + 32769.0) / 65537.0;
END REAL_UNIFORM;






% RETURN A UNIFORMLY-DISTRIBUTED RANDOM INTEGER VALUE SUCH THAT
% LOWER_BOUND <= VALUE <= UPPER_BOUND.  NOTE THAT IT WILL ALSO RETURN
% THE CORRECT RESULT IF THE BOUNDS ARE REVERSED.

INTEGER PROCEDURE INT_UNIFORM (LOWER_BOUND, UPPER_BOUND);
	INTEGER LOWER_BOUND, UPPER_BOUND;
BEGIN
INT_UNIFORM := FIX (FLOAT (ABS (UPPER_BOUND - LOWER_BOUND) + 1)
	* REAL_UNIFORM) + MIN (LOWER_BOUND, UPPER_BOUND);
END INT_UNIFORM;

PROCEDURE PUTLGTLEGEND;		% PUT LENGTH LEGEND IN BUFFER
BEGIN
IF NOT HAS_LENGTH THEN BEGIN
	HAS_LENGTH := TRUE;
	BUFFER := BUFFER !! XY_STR (6,0) !! "Length: ";
	END;
END PUTLGTLEGEND;



PROCEDURE PUTLGTVALUE;		% PUT LENGTH VALUE IN BUFFER
BEGIN
STRING (4) VALSTRING;
LENGTH_VALUE := LENGTH (SNAKEPOSITIONS) / 2;
IF (LENGTH_VALUE AND 1) = 0 THEN BEGIN
	PUTLGTLEGEND;
	VALSTRING := LENGTH_VALUE;
	UNTIL LENGTH (VALSTRING) > 3 DO VALSTRING := " " !! VALSTRING;
	BUFFER := BUFFER !! XY_STR (14, 0) !! VALSTRING;
	END;
END PUTLGTVALUE;



PROCEDURE SETDOUBLE;		% SET DOUBLE SCORING AND ITS LEGEND
BEGIN
DOUBLE_SCORE := TRUE;
BUFFER := BUFFER !! XY_STR (62, 0) !! CRT_BELL !! CRT_START_BLINK
	!! "Double Scoring" !! CRT_END_BLINK;
END SETDOUBLE;



PROCEDURE PUTSCLEGEND;		% PUT SCORE LEGEND IN BUFFER
BEGIN
IF NOT HAS_SCORE THEN BEGIN
	HAS_SCORE := TRUE;
	BUFFER := BUFFER !! XY_STR (25, 0) !! "This target: ";
	END IF;
END PUTSCLEGEND;



PROCEDURE PUTSCVALUE (SCORE);	% PUT SCORE VALUE IN BUFFER
	INTEGER SCORE;
BEGIN
STRING (5) SCORESTRING;
PUTSCLEGEND;
SCORESTRING := SCORE !! "00";
UNTIL LENGTH (SCORESTRING) > 4 DO SCORESTRING := " " !! SCORESTRING;
BUFFER := BUFFER !! XY_STR (38,0) !! SCORESTRING;
PUTTOTVALUE;
END PUTSCVALUE;

PROCEDURE PUTTOTLEGEND;		% PUT TOTAL LEGEND IN BUFFER

BEGIN
IF NOT HAS_TOTAL THEN BEGIN
	HAS_TOTAL := TRUE;
	BUFFER := BUFFER !! XY_STR (47, 0) !! "Total: ";
	END IF;
END PUTTOTLEGEND;



PROCEDURE PUTTOTVALUE;		% PUT TOTAL VALUE IN BUFFER

BEGIN
STRING (7) TOTALSCORESTRING;
PUTTOTLEGEND;
TOTALSCORESTRING := TOTAL_SCORE !! "00";
UNTIL LENGTH (TOTALSCORESTRING) > 6 DO
	TOTALSCORESTRING := " " !! TOTALSCORESTRING;
BUFFER := BUFFER !! XY_STR (53, 0) !! TOTALSCORESTRING;
END PUTTOTVALUE;




% PUT THE SCREEN IMAGE OF THE TARGET IN THE OUTPUT BUFFER

PROCEDURE SCREEN_TARGET (TARGET);

	INTEGER TARGET;

BEGIN
INTEGER LOCATION;

LOCATION := BIT_TO_LOC (TARG_BITPOINTER [TARGET]);

IF TARG_SURPRIZE [TARGET] THEN
	BUFFER := BUFFER !!
	CRT_MOVE !! SUBSTR (LOCATION, 1, 2)	!! "?====" !!
	CRT_MOVE !! SUBSTR (LOCATION+1, 1, 2)	!! "?   =" !!
	CRT_MOVE !! SUBSTR (LOCATION+2, 1, 2)	!! "?===="
ELSE
	BUFFER := BUFFER !!
	CRT_MOVE !! SUBSTR (LOCATION, 1, 2) !!
		TARG_POINTS [TARGET]		!! "====" !!
	CRT_MOVE !! SUBSTR (LOCATION+1, 1, 2)	!! "0   =" !!
	CRT_MOVE !! SUBSTR (LOCATION+2, 1, 2)	!! "0====";

END SCREEN_TARGET;

% RE-PAINT THE SCREEN WITH ALL CURRENT INFORMATION.

PROCEDURE REFRESH;

BEGIN
INTEGER I, J;
BOOLEAN CONTIGUOUS;

MAKE_WALLS;
HAS_SCORE := HAS_TOTAL := HAS_LENGTH := FALSE;
PUTLGTVALUE;
PUTTOTVALUE;
IF DOUBLE_SCORE THEN SETDOUBLE;
IF TARG_COUNT > 0 THEN FOR I := 1 STEP 1 UNTIL TARG_COUNT DO
	SCREEN_TARGET (I);
PUTBUFFER;

% GENERATE EACH HORIZONTALLY CONTIGUOUS GROUP OF SNAKE CHARACTERS,
% PRECEEDED BY THE APPROPRIATE CURSOR POSITIONING CHARACTERS.

CONTIGUOUS := FALSE;
FOR I := 82 STEP 1 UNTIL 1839 DO BEGIN
	J := MOD (I, 80);
	IF  (TBIT (SNAKEBITS, I) AND (J <> 0) AND (J <> 1)) THEN BEGIN
		IF NOT CONTIGUOUS THEN BEGIN
			BUFFER := BUFFER !! CRT_MOVE 
				!! SUBSTR (BIT_TO_LOC(I), 1, 2);
			CONTIGUOUS := TRUE;
			END;
		BUFFER := BUFFER !! SNAKE_CHAR;
		END
	ELSE BEGIN
		CONTIGUOUS := FALSE;
		END;
	END LOOP;
PUTBUFFER;

END REFRESH;

PROCEDURE MAKE_TARGET;

BEGIN

INTEGER
	NEW_BITPOINTER,
	NEW_LOCATION;

BOOLEAN SURPRIZE;



% DECIDE WHETHER TO TRY TO MAKE A TARGET DURING THE CURRENT TURN
% USING A PROBABILITY COMPUTED FROM THE NUMBER OF EXISTING TARGETS.
% THEN COMPUTE A UNIFORMLY DISTRIBUTED RANDOM BYTEPOINTER.  IF THE
% CORRESPONDING LOCATION IS UNOCCUPIED, THEN A TARGET WILL BE CREATED
% AT THAT LOCATION.

BOOLEAN PROCEDURE OK_TO_MAKE_TARGET;

BEGIN
REAL LIMIT;

IF TARG_COUNT >= MAX_TARGETS THEN OK_TO_MAKE_TARGET := FALSE
ELSE BEGIN
    LIMIT := (1.0 / FLOAT (TARG_COUNT + 1)) ^ 2.0;
    IF (REAL_UNIFORM > LIMIT) THEN OK_TO_MAKE_TARGET := FALSE
    ELSE BEGIN
        NEW_BITPOINTER := INT_UNIFORM (81, 1484);
        IF (SUBSTR
        (SNAKE_AND_TARGETS, NEW_BITPOINTER, NEW_BITPOINTER+164)
        AND
        SAMPLE_TARGET) = 0 THEN
            OK_TO_MAKE_TARGET := TRUE
        ELSE
            OK_TO_MAKE_TARGET := FALSE;
    END IF;
END IF;

END OK_TO_MAKE_TARGET;

% RECORD THE EXISTENCE OF A TARGET AT THE SELECTED POSITION.

PROCEDURE MARK_POSITION;

BEGIN
INTEGER I;
NEW_LOCATION := BIT_TO_LOC (I := NEW_BITPOINTER);
TARG_COUNT := TARG_COUNT + 1;
TARG_BITPOINTER [TARG_COUNT] := NEW_BITPOINTER;
SUBSTR (TARGETBITS, I, I+164) :=
	SUBSTR (TARGETBITS, I, I+164)
	OR SAMPLE_TARGET;
SUBSTR (SNAKE_AND_TARGETS, I, I+164) :=
	SUBSTR (SNAKE_AND_TARGETS, I, I+164)
	OR SAMPLE_TARGET;

END MARK_POSITION;



% CALCULATE THE POINT VALUE OF THE NEW TARGET.  20% OF THE TARGETS
% WILL HAVE THE VALUE HIDDEN FROM THE PLAYER, IN WHICH CASE THE
% SCORE WILL BE UNIFORMLY DISTRIBUTED OVER THE RANGE -9 TO +12.
% OTHERWISE, THE SCORE WILL BE UNIFORMLY DISTRIBUTED OVER THE
% RANGE +1 TO +8.  NOTE THAT THE VALUE AS SEEN BY THE PLAYER WILL
% BE 100 TIMES THESE INTERNAL VALUES.

PROCEDURE CALC_SCORE;

BEGIN

SURPRIZE := TARG_SURPRIZE [TARG_COUNT] := (REAL_UNIFORM < .20);
IF SURPRIZE THEN
	TARG_POINTS [TARG_COUNT] := INT_UNIFORM (-8, 12)
ELSE
	TARG_POINTS [TARG_COUNT] := INT_UNIFORM (1, 8);

END CALC_SCORE;



% CALCULATE THE NUMBER OF TURNS OVER WHICH THE TARGET WILL LIVE IF THE
% SNAKE DOESN'T HIT IT FIRST.  THIS IS UNIFORMLY DISTRIBUTED OVER THE
% RANGE 1 - 200.

PROCEDURE CALC_DURATION;

TARG_DURATION [TARG_COUNT] := INT_UNIFORM (1, 200);

% ================= START OF MAKE_TARGET EXECUTION ===================

IF OK_TO_MAKE_TARGET THEN BEGIN
	MARK_POSITION;
	CALC_SCORE;
	CALC_DURATION;
	SCREEN_TARGET (TARG_COUNT);
	END;

END MAKE_TARGET;

PROCEDURE CHECK_TARGETS;

BEGIN


% THIS PROCEDURE IS EXECUTED WHETHER THE SNAKE HAS COLLIDED WITH
% A TARGET OR NOT.  IT DECREMENTS THE DURATION COUNTER OF EACH
% TARGET AND ERASES THOSE WHOSE METER HAS RUN OUT.

PROCEDURE PUNCH_THEIR_TICKETS;

BEGIN
INTEGER I, J, CUR_BIT, POSITION;
BOOLEAN NO_MORE;
NO_MORE := (TARG_COUNT = 0);
I := 1;
UNTIL NO_MORE DO BEGIN
TARG_DURATION [I] := TARG_DURATION [I] - 1;
IF TARG_DURATION [I] < 1 THEN BEGIN
    CUR_BIT := TARG_BITPOINTER [I];
    SUBSTR (TARGETBITS, CUR_BIT, CUR_BIT+164) :=
        SUBSTR (TARGETBITS, CUR_BIT, CUR_BIT+164)
        AND NOT_SAMPLE_TARGET;
    SUBSTR (SNAKE_AND_TARGETS, CUR_BIT, CUR_BIT+164) :=
        SUBSTR (SNAKE_AND_TARGETS, CUR_BIT, CUR_BIT+164)
        AND NOT_SAMPLE_TARGET;
    POSITION := BIT_TO_LOC (CUR_BIT);
    BUFFER := BUFFER !!
        CRT_MOVE !! SUBSTR (POSITION, 1, 2)      !! "     " !!
        CRT_MOVE !! SUBSTR (POSITION+1, 1, 2)    !! "     " !!
        CRT_MOVE !! SUBSTR (POSITION+2, 1, 2)    !! "     ";
    IF I < TARG_COUNT THEN BEGIN
        FOR J := I STEP 1 UNTIL (TARG_COUNT-1) DO BEGIN
            TARG_BITPOINTER [J] := TARG_BITPOINTER [J+1];
            TARG_POINTS     [J] := TARG_POINTS     [J+1];
            TARG_DURATION   [J] := TARG_DURATION   [J+1];
            TARG_SURPRIZE   [J] := TARG_SURPRIZE   [J+1];
            END LOOP;
        END IF;
    TARG_COUNT := TARG_COUNT - 1;
    END
ELSE BEGIN
    I := I + 1;
    END IF;
NO_MORE := (I > TARG_COUNT);
END OUTER LOOP;

END PUNCH_THEIR_TICKETS;

% =============== START OF CHECK_TARGETS EXECUTION ==================


% IF THE SNAKE HAS COLLIDED WITH A TARGET, THEN FIND OUT WHICH TARGET,
% CALCULATE AND DISPLAY THE SCORE, AND SET THE TARGET DURATION SO
% THAT IT WILL BE ERASED IMMEDIATELY.

IF TBIT(TARGETBITS, NEXT_BITPOINTER) THEN BEGIN
    INTEGER I, VICTIM, SCORE;
    VICTIM := 0;

    FOR I := 1 STEP 1 UNTIL TARG_COUNT DO BEGIN
        INTEGER CUR_BITPOINTER;
        CUR_BITPOINTER := TARG_BITPOINTER [I];
        IF ((NEXT_BITPOINTER >= CUR_BITPOINTER) AND
            (NEXT_BITPOINTER < CUR_BITPOINTER+5))
        OR ((NEXT_BITPOINTER > CUR_BITPOINTER+79) AND
            (NEXT_BITPOINTER < CUR_BITPOINTER+85))
        OR ((NEXT_BITPOINTER > CUR_BITPOINTER+159) AND
            (NEXT_BITPOINTER < CUR_BITPOINTER+165))  THEN VICTIM := I;
        END WHILE VICTIM = 0;

    IF VICTIM <> 0 THEN BEGIN
        SCORE := TARG_POINTS [VICTIM];
        IF DOUBLE_SCORE THEN SCORE := 2 * SCORE;
        TOTAL_SCORE := TOTAL_SCORE + SCORE;
        IF SCORE < 0
            THEN MULTIBEEP (5)
            ELSE BUFFER := BUFFER !! CRT_BELL;
        TARG_DURATION [VICTIM] := 0;
        PUTSCVALUE (SCORE);
        END IF;

    END IF;

PUNCH_THEIR_TICKETS;

END CHECK_TARGETS;

% =========== START OF GENERATE_OUTPUT EXECUTABLE CODE ============

INIT_GAME;

WHILE STILL_RUNNING DO BEGIN

IF CTL_WORD = 0 THEN GOTO DONE_WITH_INPUT;
LOCAL_CONTROL := CTL_WORD;
CTL_WORD := 0;
TRANSMIT (CTL_LOCK, -1);
GOTO CHECK_INPUT [LOCAL_CONTROL];
GOTO DONE_WITH_INPUT;

CHECK_INPUT [27R8]:		% UP-ARROW
IF DIRECTION = GO_DOWN
	THEN BUFFER := BUFFER !! CRT_BELL
	ELSE DIRECTION := GO_UP;
GOTO DONE_WITH_INPUT;

CHECK_INPUT [32R8]:		% DOWN-ARROW
IF DIRECTION = GO_UP
	THEN BUFFER := BUFFER !! CRT_BELL
	ELSE DIRECTION := GO_DOWN;
GOTO DONE_WITH_INPUT;


CHECK_INPUT [30R8]:		% RIGHT-ARROW
IF DIRECTION = GO_LEFT
	THEN BUFFER := BUFFER !! CRT_BELL
	ELSE DIRECTION := GO_RIGHT;
GOTO DONE_WITH_INPUT;

CHECK_INPUT [31R8]:		% LEFT-ARROW
IF DIRECTION = GO_RIGHT
	THEN BUFFER := BUFFER !! CRT_BELL
	ELSE DIRECTION := GO_LEFT;
GOTO DONE_WITH_INPUT;

CHECK_INPUT [14R8]:		% ERASE-PAGE (TO REFRESH SCREEN)
REFRESH;
GOTO DONE_WITH_INPUT;

CHECK_INPUT [33R8]:		% ESCAPE (MAKES BREAK FILE)
BUFFER := BUFFER !! CRT_HOME !! CRT_ROLL !! CRT_NEWLINE
	!! "Break file in progress." !! CRT_NEWLINE;
TIDKILL (READTASKID);
PUTBUFFER;
BREAKFILE ("<0>");

DONE_WITH_INPUT:

MAKE_TARGET;
SUBSTR (NEXT_LOCATION, 1, 2) :=
	SUBSTR (SNAKEPOSITIONS,
	LENGTH (SNAKEPOSITIONS)-1,
	LENGTH (SNAKEPOSITIONS));
NEXT_LOCATION := NEXT_LOCATION + DISPLACEMENT [DIRECTION];
NEXT_BITPOINTER := LOC_TO_BIT (NEXT_LOCATION);

IF TBIT(SNAKEBITS, NEXT_BITPOINTER) THEN BEGIN
    STILL_RUNNING := FALSE;
    BUFFER := BUFFER !! CRT_MOVE !! SUBSTR (NEXT_LOCATION, 1, 2)
           !! COLLISION_CHAR;
    MULTIBEEP (2);
    END
ELSE BEGIN
    CHECK_TARGETS;
    BUFFER := BUFFER !! CRT_MOVE !! SUBSTR (NEXT_LOCATION, 1, 2)
           !! SNAKE_CHAR;
    SBIT (SNAKEBITS, NEXT_BITPOINTER);
    SBIT (SNAKE_AND_TARGETS, NEXT_BITPOINTER);
    SNAKEPOSITIONS
        := SNAKEPOSITIONS
        !! SUBSTR (NEXT_LOCATION, 1, 2);
    IF LENGTH_CONTROL = LENGTH_INTERVAL THEN BEGIN
        LENGTH_CONTROL := 0;		% LET SNAKE GROW LONGER
        PUTLGTVALUE;
        IF LENGTH (SNAKEPOSITIONS) = 400 THEN SETDOUBLE;
        END
    ELSE BEGIN				% ELSE SLURP UP THE TAIL
        LENGTH_CONTROL := LENGTH_CONTROL + 1;
        BUFFER := BUFFER
            !! CRT_MOVE
            !! SUBSTR (SNAKEPOSITIONS, 1, 2)
            !! " ";
        SUBSTR (END_LOCATION, 1, 2) := SUBSTR (SNAKEPOSITIONS, 1, 2);
        SNAKEPOSITIONS
            := SUBSTR (SNAKEPOSITIONS, 3, LENGTH (SNAKEPOSITIONS));
        END_BITPOINTER := LOC_TO_BIT (END_LOCATION);
        CBIT (SNAKEBITS, END_BITPOINTER);
        CBIT (SNAKE_AND_TARGETS, END_BITPOINTER);
        END;
    END;

PUTBUFFER;

END OUTER LOOP;

FINAL_LENGTH := LENGTH (SNAKEPOSITIONS) / 2;

END GENERATE_OUTPUT;

PROCEDURE DO_LOG;

BEGIN



BOOLEAN PROCEDURE GET_LOG;

BEGIN

INTEGER CHR_CNT, ERRORCODE;


PROCEDURE LOWERCASE (STRPARAM);
	STRING STRPARAM;
BEGIN
INTEGER I;
IF  LENGTH(STRPARAM) > 0
AND BYTE (STRPARAM, 1) > 140R8
AND BYTE (STRPARAM, 1) < 173R8
	THEN BYTE (STRPARAM, 1) := BYTE (STRPARAM, 1) - 40R8;
FOR I := 2 STEP 1 UNTIL LENGTH (STRPARAM) DO
	IF  BYTE (STRPARAM, I) > 100R8
	AND BYTE (STRPARAM, I) < 133R8
		THEN BYTE (STRPARAM, I) := BYTE (STRPARAM, I) + 40R8;
END LOWERCASE;


% ==================== START OF GET_LOG EXECUTION =====================

CREATE (LOGNAME, CREATE_ERR);
CREATE_ERR:

OPEN (LOGCHAN, LOGNAME, OPENERR);
GO TO OPEN_OK;

OPENERR:
	GET_LOG := FALSE;
	READERROR (ERRORCODE);
	BUFFER := CRT_ERASE_PAGE 
		!! "Error on opening log file <QT>SERPENT_SCORERS<QT>:"
		!! CRT_NEWLINE !! ERRMESSAGE (ERRORCODE)
		!! CRT_NEWLINE;
	PUTBUFFER;
GO TO EXIT;

OPEN_OK:
CHR_CNT := SIZE (BUFFER);
BYTEREAD (LOGCHAN, ADDRESS(BUFFER), CHR_CNT, INPERR);
GO TO INPOK;
INPERR:
READERROR (ERRORCODE);
IF ERRORCODE <> END_OF_FILE THEN BEGIN
	BUFFER := CRT_ERASE_PAGE
		!! "Error on reading log file <QT>SERPENT_SCORERS<QT>:"
		!! CRT_NEWLINE !! ERRMESSAGE (ERRORCODE)
		!! CRT_NEWLINE;
	PUTBUFFER;
	CLOSE (LOGCHAN);
	GET_LOG := FALSE;
	GO TO EXIT;
	END;
INPOK:
SETCURRENT (BUFFER, CHR_CNT);
CLOSE (LOGCHAN);
IF (MOD (CHR_CNT, 34) <> 0) THEN BEGIN
	BUFFER := CRT_ERASE_PAGE !! "Invalid log file." !! CRT_NEWLINE;
	PUTBUFFER;
	GET_LOG := FALSE;
	GO TO EXIT;
	END;

IF TOTAL_SCORE > 0 THEN BEGIN
	INTEGER YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, I;
	STRING (34) LOCALSTRING;
	STRING (2) SMALLSTRING;
	USERNAME (LOCALSTRING, -1, 0);
	LOWERCASE (LOCALSTRING);
	LOCALSTRING := LOCALSTRING !! " ";
	UNTIL LENGTH(LOCALSTRING) > 19 DO
		LOCALSTRING := LOCALSTRING !! ".";
	IF LENGTH (LOCALSTRING) > 20 THEN SETCURRENT (LOCALSTRING, 20);
	LOCALSTRING := LOCALSTRING !! SUBSTR (TOTAL_SCORE, 1, 2);
	LOCALSTRING := LOCALSTRING !! SUBSTR (FINAL_LENGTH, 1, 2);
	GTIME (YEAR, MONTH, DAY, HOUR, MINUTE, SECOND);
	SMALLSTRING := DAY;
	IF LENGTH (SMALLSTRING) < 2 THEN
		SMALLSTRING := " " !! SMALLSTRING;
	LOCALSTRING := LOCALSTRING !! SMALLSTRING !! "-";
	I := (MONTH - 1) * 3 + 1;
	LOCALSTRING := LOCALSTRING !! SUBSTR
		("JanFebMarAprMayJunJulAugSepOctNovDec", I, I+2)
		!! "-";
	SMALLSTRING := YEAR;
	IF LENGTH (SMALLSTRING) < 2 THEN
		SMALLSTRING := "0" !! SMALLSTRING;
	LOCALSTRING := LOCALSTRING !! SMALLSTRING !! CRT_NEWLINE;
	BUFFER := BUFFER !! LOCALSTRING;
	END;

GET_LOG := TRUE;

EXIT:
END GET_LOG;

/*
	THE FOLLOWING IS A BUBBLE SORT WHICH TAKES THE 34-BYTE RECORDS
	IN THE BUFFER AND SORTS THEM IN DESCENDING ORDER OF SCORE.  IT
	THEN WRITES THE BUFFER BACK TO THE LOG FILE.  NOTE THAT THE
	BUFFER MAY CONTAIN ZERO OR ONE RECORDS, IN WHICH CASE NO
	SORTING WILL TAKE PLACE.  THE FORMAT OF THE RECORDS IS:

		POSITION:	DESCRIPTION:

		1-20		USER NAME
		21-22		SCORE
		23-24		SNAKE LENGTH
		25-33		DATE IN FORMAT DD-Mmm-YY
		34		"<12>" (IN OLD SNAKE IT WAS "<0>")
*/



PROCEDURE SORT_LOG;

BEGIN

INTEGER REC_CNT, CHR_CNT, I, J, K;
STRING (34) TEMP;

REC_CNT := LENGTH (BUFFER) / 34;
FOR I := REC_CNT-1 STEP -1 UNTIL 1 DO BEGIN
    K := 0;
    FOR J := 1 STEP 1 UNTIL I DO BEGIN
        IF (SUBSTR(BUFFER,K+21,K+22)<SUBSTR(BUFFER,K+55,K+56)) THEN
            BEGIN
            TEMP := SUBSTR (BUFFER, K+1, K+34);
            SUBSTR (BUFFER, K+1, K+34) := SUBSTR (BUFFER, K+35, K+68);
            SUBSTR (BUFFER, K+35, K+68) := TEMP;
            END IF;
        K := K + 34;
        END J_LOOP;
    END I_LOOP;

CHR_CNT := MIN (LENGTH(BUFFER), 34*19);
OPEN (LOGCHAN, LOGNAME);
BYTEWRITE (LOGCHAN, ADDRESS(BUFFER), CHR_CNT, WRITERR);
LOG_WRITE_ERR := 0;
GO TO WRITEOK;
WRITERR:
READERROR (LOG_WRITE_ERR);
WRITEOK:
CLOSE (LOGCHAN);

END SORT_LOG;



PROCEDURE SHOW_LOG;

BEGIN

INTEGER I, J, REC_CNT;

BOOLEAN OLD_SNAKE;

STRING (6) SCORE_STR;
STRING (4) LGT_STR;
STRING (5) NUM_STR;

LITERAL MAX_RECS (18);

INTEGER ARRAY SCORE [1:MAX_RECS], SNAKE_LGT [1:MAX_RECS];

STRING (20) ARRAY NAME  [1:MAX_RECS];
STRING (9)  ARRAY DATE  [1:MAX_RECS];
STRING (1)  ARRAY DELIM [1:MAX_RECS];

% UNPACK BUFFER FROM DISK FORMAT

REC_CNT := MIN (MAX_RECS, LENGTH(BUFFER)/34);
OLD_SNAKE := FALSE;
J := 0;
FOR I := 1 STEP 1 UNTIL REC_CNT DO BEGIN
	NAME [I] := SUBSTR (BUFFER, J+1, J+20);
	DATE [I] := SUBSTR (BUFFER, J+25, J+33);
	DELIM [I] := SUBSTR (BUFFER, J+34);
	IF ((DELIM [I] = "<0>") AND (SCORE [I] <> 0))
		THEN OLD_SNAKE := TRUE;
	SUBSTR (SCORE[I], 1, 2) := SUBSTR (BUFFER, J+21, J+22);
	SUBSTR (SNAKE_LGT[I], 1, 2) := SUBSTR (BUFFER, J+23, J+24);
	J := J + 34;
	END LOOP;


% NOW RE-BUILD BUFFER IN DISPLAY FORMAT

BUFFER := CRT_ERASE_PAGE
	!! XY_STR (40,0) !! "Snake"
	!! XY_STR (11,1) !! "Player"
	!! XY_STR (33,1) !! "Score  Length   Date"
	!! CRT_NEWLINE !! CRT_NEWLINE;

FOR I := 1 STEP 1 UNTIL REC_CNT DO BEGIN
    IF SCORE [I] <> 0 THEN BEGIN
	NUM_STR := I !! ".";
	UNTIL LENGTH(NUM_STR) > 4 DO NUM_STR := " " !! NUM_STR;
	BUFFER := BUFFER !! NUM_STR !! "      " !! NAME [I] !! " ";
	SCORE_STR := SCORE [I] !! "00";
	UNTIL LENGTH(SCORE_STR) > 5 DO SCORE_STR := " " !! SCORE_STR;
	BUFFER := BUFFER !! SCORE_STR !! "  ";
	LGT_STR := SNAKE_LGT [I];
	UNTIL LENGTH(LGT_STR) > 3 DO LGT_STR := " " !! LGT_STR;
	BUFFER := BUFFER !! LGT_STR !! "   " !! DATE [I];
	IF DELIM [I] = "<0>" THEN BUFFER := BUFFER !! " *";
	BUFFER := BUFFER !! CRT_NEWLINE;
	END IF;
    END LOOP;


IF LOG_WRITE_ERR <> 0 THEN
	BUFFER := BUFFER
		!! "Error on writing log file <QT>SERPENT_SCORERS<QT>:"
		!! CRT_NEWLINE !! ERRMESSAGE (LOG_WRITE_ERR);

BUFFER := BUFFER !! CRT_NEWLINE;
BUFFER := BUFFER !! "Your score:  "
	!! TOTAL_SCORE !! "00                       ";
PUTBUFFER;

END SHOW_LOG;



% ====================== START OF DO_LOG EXECUTION ====================

TIDKILL (READTASKID);
IF GET_LOG THEN BEGIN
	SORT_LOG;
	SHOW_LOG;
	END;

END DO_LOG;

% SEE IF THE PLAYER WANTS TO PLAY THE GAME AGAIN

PROCEDURE TRY_AGAIN;

BEGIN
INTEGER CHR_CNT;
BOOLEAN VALID_ANSWER;
STRING (1) ANSWER;

VALID_ANSWER := FALSE;
UNTIL VALID_ANSWER DO BEGIN
	BUFFER := "Play again (Y or N)?  ";
	PUTBUFFER;
	ANSWER := "";
	LINEREAD (INPCHAN, ADDRESS(BUFFER), CHR_CNT, 133, INPERR);
	INPERR:
	SETCURRENT (BUFFER, CHR_CNT);
	IF CHR_CNT > 0 THEN BEGIN
		ANSWER := SUBSTR (BUFFER, 1);
		BYTE (ANSWER, 1) := BYTE (ANSWER, 1) AND 137R8;
		END;
	IF ANSWER = "Y" THEN BEGIN
		PLAY_AGAIN := TRUE;
		VALID_ANSWER := TRUE;
		END
	ELSE IF ANSWER = "N" THEN BEGIN
		PLAY_AGAIN := FALSE;
		VALID_ANSWER := TRUE;
		END
	ELSE BEGIN
		BUFFER := CRT_ERASE_PAGE
			!! "Invalid answer --" !! CRT_NEWLINE;
		END IF;
	END LOOP;

END TRY_AGAIN;



%=================  START OF MAIN PROGRAM EXECUTION  ==================

INIT_PROGRAM;
GET_START;
WHILE PLAY_AGAIN DO BEGIN
	GENERATE_OUTPUT;
	DO_LOG;
/*	TRY_AGAIN;  */
	PLAY_AGAIN := FALSE	/* TEMP FIX */
	END;
TERMINATE_PROGRAM;

END OF SERPENT.
